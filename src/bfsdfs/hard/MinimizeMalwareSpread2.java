/*

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those
 two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no
  more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

**We will remove one node from the initial list, completely removing it and any connections from this node to any other node.**
  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial),
   return such a node with the smallest index.



Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1
Example 3:

Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1


Note:

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length

 */
package bfsdfs.hard;

import bfsdfs.UnionFind;

import java.util.HashSet;
import java.util.Set;

/**
 * Created by poorvank.b on 23/10/18.
 */
public class MinimizeMalwareSpread2 {

    public int minMalwareSpread(int[][] graph, int[] initial) {

        int n = graph.length;

        if(initial.length==1) {
            return initial[0];
        }

        int min=Integer.MAX_VALUE;
        int ans=0;

        for (int remove: initial) {
            UnionFind unionFind = new UnionFind(n);

            for (int i=0;i<n;i++) {
                for (int j=0;j<n;j++) {
                    if(i!=remove && j!=remove && graph[i][j]==1) {
                        unionFind.union(i,j);
                    }
                }
            }

            Set<Integer> seen = new HashSet<>(); // don't count already seen root
            int totalInfected=0;
            for (int init : initial) {
                if(init==remove) {
                    continue;
                }

                int root = unionFind.find(init);
                int size = unionFind.size[root];

                if(seen.add(root)) {
                    totalInfected+=size;
                }
            }

            if(totalInfected<min) { // find minimum infected
                min = totalInfected;
                ans=remove;
            }else if (totalInfected == min && remove < ans){
                ans=remove;
            }

        }

        return ans;


    }

    public static void main(String[] args) {
        int[][] graph = new int[][]{
                {1,1,1,0},{1,1,0,0},{1,0,1,0},{0,0,0,1}
        };
        System.out.println(new MinimizeMalwareSpread2().minMalwareSpread(graph,new int[]{3,2}));
    }

}

/*

The key difference here is that the removed point will be completely isolated.
So we can create union find for each case that the initial element is removed, and calculate the total
infected number in this case, then find the minimum case. If equal, find the smallest index.

 */